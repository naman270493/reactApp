Map, Filter and Reduce in Javascript

With functional programming you'll never have to write a for loop again.
When you call map on an array, it executes that callback on every element within it, returning a new array with all of the values that the callback returned.

map passes three arguments to your callback
The current item in the array
The array index of the current item
The entire array you called map on 

var tasks = [
 
  {
 
    'name'     : 'Write for Envato Tuts+',
 
    'duration' : 120
 
  },
 
  {
 
    'name'     : 'Work out',
 
    'duration' : 60
 
  },
 
  {
 
    'name'     : 'Procrastinate on Duolingo',
 
    'duration' : 240
 
  }
 
];
Using for loop
var task_names = [];
 
for (var i = 0, max = tasks.length; i < max; i += 1) {
 
    task_names.push(tasks[i].name);
 
}


Using forEach

var task_names = [];
 
tasks.forEach(function (task) {
 
    task_names.push(task.name);
     
});
Using map
var task_names = tasks.map(function (task, index, array) {
 
    return task.name; 
 
});
Don't have to create a new array and push into it. map returns the finished product all in one go
forEach returns undefined, so it doesn't chain with other array methods. map returns an array, so you can chain it with other array methods.
Arrow functions let us leave out the return keyword in one-liners. 
var task_names = tasks.map((task) => task.name );

Filter - It takes an array, and filters out unwanted elements.
var difficult_tasks = [];
 
tasks.forEach(function (task) {
    if (task.duration >= 120) {
        difficult_tasks.push(task);
    }
});
With ES6

var difficult_tasks = tasks.filter((task) => task.duration >= 120 );

Reduce - takes all of the elements in an array, and reduces them into a single value.
reduce passes your callback four arguments
current value, prev value, current index, array you called reduce on
var total_time = tasks.reduce(function (previous, current) {
    return previous + current;
}, 0);
Using arrow
var total_time = tasks.reduce((previous, current)=> previous + current );
For Concatenation 
var array_of_arrays = [[1, 2], [3, 4], [5, 6]];
var concatenated = array_of_arrays.reduce( function (previous, current) {
        return previous.concat(current);	});
.find() method - get the value of the first element in the array that satisfies the provided condition
The some() method checks if any of the elements in an array pass a test (provided as a function)


let sum = arr.reduce((acc, val) => {
  return acc + val;
}, 100);
here we want to calculate sum but with initial value of 100

data.reduce(function(p,c,i){ return p.concat(c.books)},[]);
here p will be empty array in the beginnning starting with arr[0]i.e. first array


JavaScript has many frameworks among which we can choose depending on our need.  Advantages provided by the JavaScript Frameworks:
Efficiency: With the use of pre-built patterns and functions, the development of the applications became easy.
Security: As JavaScript is an open source community, its top frameworks have strong security arrangements.
Cost Reduction: JavaScript Frameworks are free for public use as they are open source. 
Why React?
the data is received from various sources like initial data, real-time data and user input data which is passed to the dispatcher. The dispatcher then forwards this data to the store, from where it ultimately comes to the view.
Each time new data is added or any data is updated at the back end, the browser reloads the web page and repeats the whole process again. Only after this, we can see the updated data on the view.  DOM is an object that is created by the browser each time a web page is loaded which can dynamically add or remove the data at the back end. But each time any modifications were done a new DOM is created for the same page. 
This repeated creation of DOM results in unnecessary memory wastage and a decrease in applications performance.
Now, each time any data is added or updated from the back end, ReactJS uses a new tactic to deal with it.  it just destroys the old view. Afterward, it renders the view components with updated data and then places the new view. As a solution to the memory wastage due to DOM, React introduced Virtual DOM. 

React is a component-based library which is used to develop interactive UI’s. ReactJS is only a frontend library and not the whole framework, which deals with the View component of MVC
In ReactJS, everything is a component that are integrated together to form a bigger dynamic application

The entire application can be modeled as a set of independent components.
This enables us to keep logic and views separate. React renders multiple components simultaneously. Components can be either stateful or stateless.

The HTML generated by the component needs to be displayed on to the DOM, whatever we pass in render function needs to be displayed on screen. For this, we make a reference to an existing DOM node 
the DOM is part of the ‘react-dom’ library. So in the next line, we have to instruct JavaScript to import ‘react-dom’ library from the installed npm module.

Virtual DOM: Like an actual DOM, virtual DOM is also a node tree that lists the elements and their attributes and content as Objects and their properties
Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.
Then the difference between the previous DOM representation and the new one is calculated.
Once the calculations are done, the real DOM will be updated with only the things that have actually changed. the virtual DOM acts as patches and are applied to the elements which are updated or changed, in the real DOM.

Server-Side Rendering- Server-Side rendering allows you to pre-render the initial state of your react components at the server side only
Thus, the browser can now start rendering without having to wait for all the JavaScript to be loaded and executed. As a result, the webpage loads faster. Here the user will be able to see the web page in spite of React still downloading the JavaScript, creating the virtual DOM, linking events, etc. at the back end.

One-Way Data Binding- The major advantage of One-Way-Data binding is that throughout the application the data flows in a single direction which gives you better control over it.
Testability 
Babel- This is the tool used to convert ES6 to ES5. This is done because not all web browsers can render React (ES6+JSX) directly. forms bundle.js

facebook component - Search Bar
Add Post 
Notifications Bar 
Feed Updates
Profile Info
Chat Window

State - 
State allows us to create components that are dynamic and interactive. The state can only be set inside the constructor. 

Keys are the means by which React identifies components uniquely. 

 Each of these components exists within the same space but execute independently from one another. React components have their own structure, methods as well as APIs. They are reusable and can be injected into interfaces as per need
 Now that you have understood what is a component and what are its advantages, let’s now find out how to feed data to these components. 
 
 Props stand for Properties. Prop is a way of passing data from parent to child component. 
 
 React Components – Props and States in ReactJS with Examples
Recommended by 71 users

Swatee Chand Sep 03,2017
React Components – Props and States in ReactJS with Examples  Add to Bookmark  Email this Post  6.8K     0
“In React, everything is a component”
If you are familiar with React, then you must have heard or read this phrase many times. But do you know what it means exactly and how it is used? If you don’t, then read this blog to learn all about React components and the different phases in the lifecycle. I am sure by the time you finish reading this blog you will have a complete understanding about React components and the concepts surrounding it. But before proceeding, take a quick look at the topics I will be discussing:

What are React Components?
Advantages of React Components
Props
States
States vs Props
React Component Lifecycle
What are React Components?
Earlier the developers had to write 1000 lines of code for developing a simple single page application. Most of those applications followed the traditional DOM structure and making changes to them was very challenging and a tedious task for the developers. They manually had to search for the element which needed the change and update it accordingly. Even a small mistake would lead to application failure. Moreover, updating DOM was very expensive. Thus, the component-based approach was introduced. In this approach, the entire application is divided into logical chunks which are called the Components. React was one of the frameworks who opted for this approach.

Let’s now understand what these components are.

React components are considered as the building blocks of the User Interface. Each of these components exists within the same space but execute independently from one another. React components have their own structure, methods as well as APIs. They are reusable and can be injected into interfaces as per need. To have a better understanding, consider the entire UI as a tree. Here the starting component becomes the root and each of the independent pieces becomes branches, which are further divided into sub-branches.

UI Tree - React Components - EdurekaThis keeps our UI organized and allows the data and state changes to logically flow from the root to branches and then to sub-branches. Components make calls to the server directly from the client-side which allows the DOM to update dynamically without refreshing the page. This is because react components are built on the concept of AJAX requests. Each component has its own interface that can make calls to the server and update them. As these components are independent of one another, each can refresh without affecting others or the UI as a whole.

We use React.createClass() method to create a component. This method must be passed an object argument which will define the React component. Each component must contain exactly one render() method. It is the most important property of a component which is responsible for parsing the HTML in JavaScript, JSX. This render() will return the HTML representation of the component as a DOM node. Therefore, all the HTML tags must be enclosed in an enclosing tag inside the render().

Following is a sample code for creating a component.

import React from 'react';
import ReactDOM from 'react-dom';

class MyComponent extends React.Component{
    render(){
        return(       
              <div>           
                <h1>Hello</h1>
                <h1>This is a Component</h1>
              </div>
        );
    }
}
ReactDOM.render(
    <MyComponent/>, document.getElementById('content')
);
GET REACT CERTIFIED TODAY!

Advantages of React Components

Code Re-usability – A component-based approach makes your application development easier and faster. If you want to use a pre-existing functionality in your code, you can just put that code in yours instead of building it from scratch. It also allows your application architecture to stay up to date over time as you can update the specific areas which need up-gradations. 
Fast Development – A component-based UI approach leads to an iterative and agile application development. These components are hosted in a library from which different software development teams can access, integrate and modify them throughout the development process.
Consistency – Implementing these reusable components helps to keep the design consistent and can provide clarity in organizing code throughout the application.
Maintainability –  Applications with a set of well-organized components can be quickly updated and you can be confident about the areas which will be affected and which won’t.
Scalability –  The development becomes easier with a properly organized library of ready to implement components. Ensuring the components are properly namespaced helps to avoid style and functionality leaking or overlapping into the wrong place as the project scales up.
Easy Integration – The component codes are stored in repositories like GitHub, which is open for public use. Application development teams are well-versed in using source code repositories, and so they are able to extract the code as needed and inject it into the application.
Now that you have understood what is a component and what are its advantages, let’s now find out how to feed data to these components. 

There are two ways the components receive data:

Props
States
Props
Props stand for Properties. They are the read-only components which work similar to the HTML attributes. Prop is a way of passing data from parent to child component. Let’s understand this with an example.

As we already know, the react components arrange the UI in the form of a tree where the parent component becomes the root and child components become branches and sub-branches. Now suppose parent component wants to send data to one of its deeply nested components. Let us say from component 1 you need to send a property to component 6. How will you do that?

prop - React Components - Edureka

You cannot pass down a property directly to the target component.So, in this case, we need to send data, layer by layer until it reaches target child component.

Since the props can only be passed from parent components, they cannot be changed. This makes them immutable. Ajax or Events can happen when data returns, so someone needs to take responsibility for handling the updates. This is where React states come into the picture.

The change in state can happen as a response to user event or system event. In other words, state is the heart of every react component which determines how the component will behave and render. 

React follows the component based approach, where the data flows through the components. In-fact, the data in React always flows from parent to child components which makes it unidirectional.

But what happens when we try to communicate from a non-parent component?
Redux provides a “store” as a solution to this problem. A store is a place where you can store all your application state together.
Now the components can “dispatch” state changes to the store and not directly to the other components. Then the components that need the updates about the state changes can “subscribe” to the store.

Just like React, Redux is also a library which is used widely for front-end development. It is basically a tool for managing both data-state and UI-state in JavaScript applications.

Principles Of Redux- 
single source of truth  - The state of the entire application is stored in an object/ state tree within a single store. The single state tree makes it easier to keep track of the changes over time
State is read-only - The only way to change the state is to trigger an action. An action is a plain JS object describing the change.An action must have a type property
Changes are made with pure functions-  In order to specify how the state tree is transformed by actions, you need pure functions. 

Action –  The only way to change the state is to trigger an action. Actions are the plain JavaScript objects which are the main source of information used to send data from the application to the store.
To call actions anywhere in the app, use dispatch()method
Reducer - Actions describe the fact that something happened, but don’t specify how the application’s state changes in response. This is the job of reducers
Based on the array reduce method, where it accepts a callback (reducer) and lets you get a single value out of multiple values. In Redux, reducers are functions (pure) that take the current state of the application and an action and then return a new state. 
Store - A store is a JavaScript object which can hold the application’s state and provide a few helper methods to access the state, dispatch actions and register listeners. The entire state/ object tree of an application is saved in a single store.

Real DOM							Virtual  DOM
1. It updates slow.				1. It updates faster.
2. Can directly update HTML.	2. Can’t directly update HTML.
3. Creates a new DOM if element updates.	3. Updates the JSX if element updates.
4. DOM manipulation is very expensive.	4. DOM manipulation is very easy.
5. Too much of memory wastage.	5. No memory wastage.

- Browsers can only read JavaScript objects but JSX in not a regular JavaScript object. Thus to enable a browser to read JSX, first, we need to transform JSX file into a JavaScript object using JSX transformers like Babel and then pass it to the browser.

Stateful Component												Stateless Component
1. Stores info about component’s state change in memory		1. Calculates the internal state of the components
2. Have authority to change state							2. Do not have the authority to change state
3. Contains the knowledge of past, current and possible future changes in state	3. Contains no knowledge of past, current and possible future state changes
4. Stateless components notify them about the requirement of the state change, then they send down the props to them.	4. They receive the props from the Stateful components and treat them as callback functions.


important lifecycle methods are:

componentWillMount() – Executed just before rendering takes place both on the client as well as server-side.
componentDidMount() – Executed on the client side only after the first render.
componentWillReceiveProps() – Invoked as soon as the props are received from the parent class and before another render is called.
shouldComponentUpdate() – Returns true or false value based on certain conditions. If you want your component to update, return true else return false. By default, it returns false.
componentWillUpdate() – Called just before rendering takes place in the DOM.
componentDidUpdate() – Called immediately after rendering takes place.
componentWillUnmount() – Called after the component is unmounted from the DOM. It is used to clear up the memory spaces.

events in react - syntactical differences :
Events are named using camel case instead of just using the lowercase.
Events are passed as functions instead of strings.

problem with mvc - 
DOM manipulation was very expensive
Applications were slow and inefficient
There was huge memory wastage
Because of circular dependencies, a complicated model was created around models and views

React Router is a powerful routing library built on top of React, which helps in adding new screens and flows to the application.
The ‘switch’ keyword is used when you want to display only a single route to be rendered amongst the several defined routes.

